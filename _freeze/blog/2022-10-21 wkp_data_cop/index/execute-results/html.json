{
  "hash": "d90d6de7c27b5b99b8b721fdd162fc53",
  "result": {
    "markdown": "---\ntitle: \"Gebruik van WKP-data\"\ndate: \"2022-10-28\"\neditor_options: \n  chunk_output_type: console\nimage: \"logo-waterkwaliteitsportaal.png\"\nformat: \n  html:\n    code-fold: show\n    toc: true\n    toc-location: right\n    toc-title: Op deze pagina\nreference-location: margin\nfilters:\n   - lightbox\nlightbox: auto\n---\n\n\n\n\n# Het waterkwaliteitsportaal\n\nAlle monitoringsdata van de waterkwaliteits van de waterbeheerders wordt beschikbaar gesteld via het [Waterkwaliteitsportaal](https://www.waterkwaliteitsportaal.nl/oppervlaktewaterkwaliteit) (WKP). In deze blogpost wil ik laten zien hoe je deze data kunt gebruiken.\n\n::: callout-tip\n## Tip\n\nJe kunt de code-blokken inklappen door op de *Code*-knop boven aan het blok te klikken.\n:::\n\n# Downloaden en uitpakken van WKP-data\n\nDe data op het WKP wordt in verschillende ZIP-bestanden beschikbaar gesteld. De eerste stappen zijn om deze bestanden te downloaden en uit te pakken. In deze post maak ik alleen gebruik van data in het IM-metingen formaat vanaf 2016. Met de onderstaande code heb ik de bestanden gedownload en uitgepakt.\n\nIk maak gebruik van de functies `walk` en `walk2`. Deze functies maken het mogelijk om zonder loops de bestanden een voor een te downloaden en uit te pakken.\n\n::: callout-tip\n## Tip\n\nJe kunt in de codeblokken klikken en dan wordt je doorverwezen naar de documentatie van die functie.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n# library(vroom)\nlibrary(twn)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .code-overflow-scroll}\n# Download\n\nurls <- \n  c(\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/MeetgegevensPerJaar/IM_Metingen_2021.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/MeetgegevensPerJaar/IM_Metingen_2020.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/MeetgegevensPerJaar/IM_Metingen_2019.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/MeetgegevensPerJaar/IM_Metingen_2018.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/MeetgegevensPerJaar/IM_Metingen_2017.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/MeetgegevensPerJaar/IM_Metingen_2016.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Meetgegevens/IM_Metingen_Biologie_2016-maand01_totenmet_04.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Meetgegevens/IM_Metingen_Biologie_2016-maand05_totenmet_07.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Meetgegevens/IM_Metingen_Biologie_2016-maand_08totenmet_12.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Meetgegevens/IM_Metingen_Biologie_2015.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Meetgegevens/IM_Metingen_Biologie_2014.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Meetgegevens/IM_Metingen_Biologie_2013.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Meetgegevens/IM_Metingen_Biologie_2012.zip\",\n\"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Meetgegevens/IM_Metingen_Biologie_2011.zip\")\n\nurls_meetpunten <- \n  c(\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2021.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2020.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2019.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2018.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2017.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2016.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2015.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2014.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2013.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2012.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Basisgegevens/Meetlocaties_2011.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Basisgegevens/Meetlocaties_Biologie_2015.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Basisgegevens/Meetlocaties_Biologie_2014.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Basisgegevens/Meetlocaties_Biologie_2013.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Basisgegevens/Meetlocaties_Biologie_2012.zip\",\n    \"https://waterkwaliteitsportaal.overheidsbestanden.nl/Oppervlaktewaterkwaliteit/Limno/Basisgegevens/Meetlocaties_Biologie_2011.zip\"\n  )\n\ndir.create(\"data-raw\")\npurrr::walk2(urls, paste0(\"data-raw/\", basename(urls)), download.file)\npurrr::walk2(urls_meetpunten, paste0(\"data-raw/\", basename(urls_meetpunten)), download.file)\n\n# Extract -----------------------------------------------------------------\n\n\n# dir.create(\"data-raw/IM-metingen\")\nfiles <- list.files(\"data-raw\", pattern = \"^IM_Metingen\", full.names = TRUE)\npurrr::walk(files, .f = ~unzip(.x, exdir = \"data-raw/IM-metingen\"))\n\nfiles_meetpunten <- list.files(\"data-raw\", pattern = \"^Meetlocaties\", full.names = TRUE)\npurrr::walk(files_meetpunten, .f = ~unzip(.x, exdir = \"data-raw/meetpunten\"))\n```\n:::\n\n\nHet resultaat is dat we een map *IM-metingen* hebben met 31 bestanden en een map *meetpunten* met 16 bestanden met meetpunten.\n\n# Inlezen WKP-data\n\nDe volgende stap is om de uitgepakte bestanden in te lezen. Gezien het grote aantal bestanden is het handig om een aanpak te verzinnen waarbij niet ieder bestand afzonderlijk ingelezen hoeft te worden.\n\n## Eerste idee\n\nHoewel de bestanden allemaal in het IM-metingen format zijn, verschilt het aantal kolommen per bestand. Om dit probleem op te lossen was mijn eerste idee om elk afzonderlijk bestand automatisch in te lezen in een lijst met `map()`. Daarna combineer ik al deze tibbles met `reduce()` en `bind_rows()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles_IM <- list.files(\"data-raw/IM-metingen/\", full.names = TRUE)\n\ndata <-\n  map(files_IM, .f = read_csv2) %>% \n  reduce(bind_rows)\n```\n:::\n\n\nDeze manier van inlezen werkt op zich wel, maar de voorwaarde is dat er genoeg computergeheugen beschikbaar is. Bij het uitproberen op mijn persoonlijke computer kwam ik erachter dat 8 Gb RAM onvoldoende was en dat dit dus misschien niet de beste oplossing is.\n\n## Alternatieve aanpak\n\nAlles in het geheugen inlezen is dus niet de optimale aanpak. Een betere aanpak is een database-achtige aanpak waarbij niet alle data in één keer in het geheugen ingelezen wordt, maar waarbij data pas wordt ingelezen wanneer dat nodig is. \n\nVoor deze aanpak is het wel handig om de bestanden eerst te uniformeren en op te schonen. Ik gebruik deze stap ook gelijk om de meetpuntcoordinaten aan de IM-metingbestanden toe te voegen.\n\n### Opschonen meetpunten\n\nVoor het opschonen van de meetpuntbestanden zijn er een paar aandachtspunten:\n\n- Dezelfde informatie zit in de verschillende bestanden niet in dezelfde kolom. De namen verschillen.\n- Er zijn soms onnodige aanhalingstekens toegevoegd, die haal ik weer weg.\n- Veel meetpunten komen in meer dan 1 bestand voor. Het is wenselijk om voor elk meeetpunt maar 1 set met informatie te hebben. Hiervoor maak ik een aparte tabel en bestand.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles_mp <- list.files(\"data-raw/meetpunten/\", full.names = TRUE)\n\nmeetpunten <- \n  tibble(pad = files_mp, bestandsnaam = basename(files_mp)) %>% \n    mutate(jaar = str_extract(bestandsnaam, \"\\\\d{4}\")) %>% \n    arrange(jaar) %>% \n    mutate(meetpuntinfo = map(pad, ~read_csv2(.x, col_types = cols(.default = col_character())))) %>% \n    unnest(meetpuntinfo) %>% \n  mutate( \n    Meetobject.namespace = case_when(\n      !is.na(Meetobject.namespace) ~ Meetobject.namespace,\n      !is.na(Namespace) ~ Namespace,\n      !is.na(Waterbeheerder.code) ~ paste0(\"NL\", Waterbeheerder.code),\n      !is.na(sub_subident) ~ paste0(\"NL\", sub_subident)),\n    Meetobject.lokaalID = coalesce(Identificatie, Meetpunt.identificatie, mpn_mpnident),\n    GeometriePunt.X_RD = coalesce(GeometriePunt.X_RD, mpn_mrfxcoor),\n    GeometriePunt.Y_RD = coalesce(GeometriePunt.Y_RD, mpn_mrfycoor),\n    Meetobject.Omschrijving = coalesce(Omschrijving, Meetpuntomschrijving, Meetpunt.omschrijving, mpn_mpnomsch)) %>% \n  select(Meetobject.namespace,\n         Meetobject.lokaalID,\n         Meetobject.Omschrijving,\n         GeometriePunt.X_RD,\n         GeometriePunt.Y_RD,\n         bestandsnaam,\n         jaar) %>% \n  mutate(across(where(is.character), ~str_remove_all(.x, '\"'))) %>% \n  mutate(across(.cols = contains(\"GeometriePunt\"), \n                .fns = ~parse_double(.x, locale = locale(decimal_mark = \".\")))) %>% \n  distinct()\n    \ndir.create(\"data\")\nmeetpunten %>% write_csv2(\"data/meetpunten_2011-2021.csv\", na = \"\")\n\n\n# Een aangepaste tabel met de meeste recente set coordinaten en zonder dummy coords.\n\nmeetpunten_clean <- \n  meetpunten %>% \n  filter(GeometriePunt.X_RD != 0, GeometriePunt.Y_RD != 0,\n         GeometriePunt.X_RD != 123546, GeometriePunt.Y_RD != 456789) %>% \n  arrange(desc(jaar)) %>% \n  group_by(Meetobject.namespace, Meetobject.lokaalID) %>% \n  summarise(GeometriePunt.X_RD = first(GeometriePunt.X_RD),\n            GeometriePunt.Y_RD = first(GeometriePunt.Y_RD),\n            Meetobject.Omschrijving = first(Meetobject.Omschrijving)) %>% \n  ungroup()\n\nmeetpunten_clean %>% write_csv2(\"data/meetpunten_2011-2021_clean.csv\", na = \"\")\n```\n:::\n\n\n### Opschonen metingen\n\nDe volgende stap is het opschonen van de metingen bestanden. Dit doe ik door de volgende stappen:\n\n- selectie van de noodzakelijke kolommen\n- verwijderen van de overbodige aanhalingstekens\n- het toevoegen van de meest recente coordinaten\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles_IM <- list.files(\"data-raw/IM-metingen/\", full.names = TRUE)\ndir.create(\"data/IM-metingen\")\n\nopschoon_fun <- function(filename){\n  \n  im_kolommen <- c(\n    \"Meetobject.namespace\",\n    \"Meetobject.lokaalID\",\n    \"MonsterCompartiment.code\",\n    \"Begindatum\",\n    \"Begintijd\",\n    \"Typering.code\",\n    \"Grootheid.code\",\n    \"Parameter.groep\",\n    \"Parameter.code\",\n    \"Parameter.omschrijving\",\n    \"Biotaxon.naam\",\n    \"Eenheid.code\",\n    \"Hoedanigheid.code\",\n    \"Levensstadium.code\",\n    \"Lengteklasse.code\",\n    \"Geslacht.code\",\n    \"Verschijningsvorm.code\",\n    \"Levensvorm.code\",\n    \"Gedrag.code\",\n    \"Waardebewerkingsmethode.code\",\n    \"Limietsymbool\",\n    \"Numeriekewaarde\",\n    \"Alfanumeriekewaarde\",\n    \"AnalyseCompartiment.code\",\n    \"Kwaliteitsoordeel.code\")\n  \n  read_csv2(filename, \n            col_types = cols(Numeriekewaarde = col_number(), \n                             Begindatum = col_date(),\n                             Begintijd = col_time(),\n                             .default = col_character()),\n            col_select = any_of(im_kolommen),\n            locale = locale(decimal_mark = \".\")) %>% \n    \n    mutate(across(where(is.character), ~str_remove_all(.x, '\"'))) %>% \n    left_join(meetpunten_clean, by = c(\"Meetobject.namespace\", \"Meetobject.lokaalID\")) %>% \n    \n    write_csv2(file.path(\"data/IM-metingen\", basename(filename)),\n               na = \"\")\n}\n\nwalk(files_IM, opschoon_fun)\n```\n:::\n\n\n# Gebruik WKP-data voor een concrete casus\n\nWe hebben de WKP-data nu beschikbaar in een vorm die we verder kunnen gebruiken. We kunnen deze data nu gaan gebruiken om vragen mee te beantwoorden. Als demonstratie gebruik ik de vraag: *Waar in Nederland zijn er (uitheemse) rivierkreeften gerapporteerd?*\n\nVoor het inlezen van de data maak ik eerst een aparte functie zodat ik niet steeds hoef na te denken over de datatypen van de verschillende kolommen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_wkp <- function(filename, lazy = FALSE){\n  read_csv2(filename, \n            col_types = cols(Begindatum = col_date(),\n                                       Begintijd = col_time(),\n                                       Numeriekewaarde = col_double(),\n                                       GeometriePunt.X_RD = col_double(),\n                                       GeometriePunt.Y_RD = col_double(),\n                                       .default = col_character()),\n            lazy = lazy)\n}\n```\n:::\n\n\nIk gebruik de inleesfunctie om de opgeschoonde bestanden een voor een in te lezen en alleen de regels met kreeften te bewaren. Dat resulteert in een `list` met dataframes die ik samenvoeg met `reduce(bind_rows)`.\n\nVoor het weergeven van de data op een kaart download ik ook de waterschapsgrenzen van PDOK.\n\n\n::: {.cell hash='index_cache/html/kreeften-data_2ded85e5eb668ca190a11d242a5ce526'}\n\n```{.r .cell-code}\nkreeften_taxa <- twn_children(\"Astacidea\", only_preferred = FALSE)\n\nwkp_bestanden <- list.files(\"data/IM-metingen/\", full.names = TRUE)\n\nkreeften <- \n  map(wkp_bestanden, ~read_wkp(.x) %>% filter(Biotaxon.naam %in% kreeften_taxa)) %>% \n  reduce(bind_rows)\n\n# Downloaden van waterschapsgrenzen van PDOK als achtergrond voor de kaarten\ndownload.file(\"https://geodata.nationaalgeoregister.nl/hwh/eenheden/atom/v1_0/downloads/AdministrativeUnits.zip\", \"data/ws_grenzen.zip\")\nunzip(\"data/ws_grenzen.zip\", exdir = \"data\")\nws_grenzen <- sf::st_read(\"data/AdministrativeUnits_ETRS89.gml\", quiet = TRUE) %>% sf::st_transform(crs = 28992)\n```\n:::\n\nNu ik alle benodigde data heb ingelezen kan ik de data eindelijk gebruiken om leuke dingen mee te doen: zoals het weergeven per jaar waar er door waterschappen kreeften zijn waargenomen en gerapporteerd aan het waterkwaliteitsportaal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkreeften %>% \n  filter(!is.na(GeometriePunt.X_RD)) %>% \n  mutate(jaar = lubridate::year(Begindatum)) %>% \n  sf::st_as_sf(coords = c(\"GeometriePunt.X_RD\", \"GeometriePunt.Y_RD\"), crs = 28992, remove = FALSE) %>% \n  ggplot() +\n  geom_sf(data = ws_grenzen, colour = \"grey\") +\n  geom_sf(alpha = 0.5) +\n  facet_wrap(~jaar) +\n  labs(title = \"(Uitheemse) rivierkreeften gerapporteerd door de waterschappen\",\n       caption = \"Bron: https://www.waterkwaliteitsportaal.nl/\")\n```\n\n::: {.cell-output-display}\n![Locaties met kreeften uit het waterkwaliteitsportaal](index_files/figure-html/kreeften-kaartjes-1.png){width=768}\n:::\n:::\n\n\nOp kaartjes is ook te zien waarom ik ervoor heb gekozen om de kreeften te selecteren. Hier is namelijk duidelijk te zien dat HHSK vanaf 2020 de kreeften uitgebreid is gaan monitoren. Iets waarvan ik denk dat het belangrijk is en waarvan ik hoop dat andere waterschappen dat voorbeeld zullen volgen.\n\n# Een alternatieve manier van inlezen\n\nDe library *vroom* kan een groot aantal tekstbestanden (.csv) indexeren en dit als een lazy[^1] dataframe beschikbaar maken. Om *vroom* te laten werken is het belangrijk dat alle bestanden dezelfde kolommen bevatten. Bij het opschonen van  de bestanden hebben we deze stap al gemaakt.\n\n[^1]: Lazy betekent dat R zo weinig mogelijk werk doet. De data wordt dus niet in het geheugen geladen zolang dat niet nodig is.\n\nHieronder staat een code-voorbeeld met *vroom* voor de kreeftendata. *Vroom* is erg snel, maar vraagt wel nog steeds veel geheugen. Daarom heb ik hierboven voor een andere aanpak gekozen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkreeften <-\n  vroom::vroom(wkp_bestanden,\n               col_types = cols(Begindatum = col_date(),\n                                Begintijd = col_time(),\n                                Numeriekewaarde = col_double(),\n                                GeometriePunt.X_RD = col_double(),\n                                GeometriePunt.Y_RD = col_double(),\n                                .default = col_character()),\n               locale = locale(decimal_mark = \",\")) %>%\n  filter(Biotaxon.naam %in% kreeften_taxa)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}